:javascript
  document.addEventListener('turbo:load', function() {
    const canvas = document.getElementById('#{chart_id}');
    if (!canvas) return;

    if (canvas.chart) {
      canvas.chart.destroy();
    }

    // Load Chart.js zoom plugin if not already loaded
    const zoomstr = 'zoom';
    const scriptstr = 'script';

    if (typeof Chart !== 'undefined' && !Chart.registry.plugins.get(zoomstr)) {
      const script = document.createElement(scriptstr);
      script.src = 'https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js';
      document.head.appendChild(script);

      script.onload = function() {
        initializeChart();
      };
    } else {
      initializeChart();
    }

    function initializeChart() {

    if ('#{chart_id}' === 'recordsChart') {
      window.refreshRecordsChartFromUI = function() {
        const input = document.getElementById('riegel-exponent');
        if (input && typeof updateChart === 'function') {
          const exponent = parseFloat(input.value);
          updateChart(exponent);
        }
      };
    }


    if ('#{chart_id}' === 'bestEffortsChart') {
      window.refreshBestEffortsChartFromUI = function() {
        const exponentInput = document.getElementById('be-riegel-exponent');
        const slider = document.getElementById('reference-distance-slider');
        if (exponentInput && slider && typeof updateBestEffortsChart === 'function') {
          const exponent = parseFloat(exponentInput.value);
          const distance = parseFloat(slider.value);
          updateBestEffortsChart(exponent, distance);
        }
      };
    }

    const canvas_context = '2d';
    const ctx = canvas.getContext(canvas_context);
    const datasets = #{datasets.to_json.html_safe};
    const chartTitle = '#{chart_title}';
    const xAxisConfig = #{(defined?(x_axis_config) ? x_axis_config : {}).to_json.html_safe}; // Make optional with default

    let isPaceMode = true;

    function paceToSpeed(paceInMinutesPerKm) {
      return 60 / paceInMinutesPerKm;
    }

    function speedToPace(speedInKmh) {
      return 60 / speedInKmh;
    }

    function formatPace(value) {
      const minutes = Math.floor(value);
      const seconds = Math.floor((value % 1) * 60);
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function formatSpeed(value) {
      return value.toFixed(1) + ' km/h';
    }

    function formatTime(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);

      if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      } else {
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
      }
    }

    const toggleButtonPlugin = {
      id: 'toggleButton',
      afterDraw: function(chart) {
        const ctx = chart.ctx;
        const chartArea = chart.chartArea;

        const buttonWidth = 100;
        const buttonHeight = 30;
        const buttonX = chartArea.right - buttonWidth - 10;
        const buttonY = chartArea.bottom - buttonHeight - 10;
        chart.toggleButton = {
          x: buttonX,
          y: buttonY,
          width: buttonWidth,
          height: buttonHeight
        };

        ctx.save();
        ctx.fillStyle = '#28a745';
        ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);

        ctx.fillStyle = '#ffffff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const buttonText = isPaceMode ? 'min/km' : 'km/h';
        ctx.fillText(buttonText, buttonX + buttonWidth/2, buttonY + buttonHeight/2);

        ctx.restore();
      }
    };

    // Store original pace values permanently
    const originalDatasets = datasets.map(dataset => {
      return {
        label: dataset.label,
        data: dataset.data.map(point => ({
          x: point.x,
          y: point.y,
          label: point.label,
          originalPace: point.y
        })),
        backgroundColor: dataset.borderColor || dataset.color,
        borderColor: dataset.borderColor || dataset.color,
        borderWidth: dataset.borderWidth || 2,
        pointRadius: dataset.pointRadius !== undefined ? dataset.pointRadius : 6,
        pointHoverRadius: dataset.pointHoverRadius !== undefined ? dataset.pointHoverRadius : 8,
        showPoints: dataset.showPoints !== undefined ? dataset.showPoints : true,
        tension: dataset.tension || 0,
        hidden: dataset.hidden || false,
        fill: false
      };
    });

    // Create a deep copy for Chart.js to use
    const chartDatasets = originalDatasets.map(dataset => ({
      ...dataset,
      data: dataset.data.map(point => ({...point})),
      pointRadius: dataset.showPoints ? dataset.pointRadius : 0,
      pointHoverRadius: dataset.showPoints ? dataset.pointHoverRadius : 0,
      pointHitRadius: dataset.showPoints ? 10 : 0,
      fill: false
    }));

    function updateChartUnits() {
      const chart = canvas.chart;

      chart.data.datasets.forEach((dataset, index) => {
        const originalDataset = originalDatasets[index];

        if (isPaceMode) {
          dataset.data = originalDataset.data.map(point => ({
            x: point.x,
            y: point.originalPace,
            label: point.label,
            originalPace: point.originalPace
          }));
        } else {
          dataset.data = originalDataset.data.map(point => ({
            x: point.x,
            y: paceToSpeed(point.originalPace),
            label: point.label,
            originalPace: point.originalPace
          }));
        }
      });

      chart.options.scales.y.title.text = isPaceMode ? 'Pace (min/km)' : 'Speed (km/h)';

      chart.options.scales.y.ticks.callback = function(value) {
        return isPaceMode ? formatPace(value) : formatSpeed(value);
      };

      chart.options.plugins.tooltip.callbacks.label = function(context) {
        const datasetLabel = context.dataset.label || '';
        if (isPaceMode) {
          const minutes = Math.floor(context.parsed.y);
          const seconds = Math.floor((context.parsed.y % 1) * 60);
          return `${datasetLabel}: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        } else {
          return `${datasetLabel}: ${context.parsed.y.toFixed(1)} km/h`;
        }
      };

      chart.update();
    }

    canvas.addEventListener('click', function(event) {
      const chart = canvas.chart;
      if (!chart.toggleButton) return;

      const rect = canvas.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;

      if (clickX >= chart.toggleButton.x &&
          clickX <= chart.toggleButton.x + chart.toggleButton.width &&
          clickY >= chart.toggleButton.y &&
          clickY <= chart.toggleButton.y + chart.toggleButton.height) {

        isPaceMode = !isPaceMode;
        updateChartUnits();
        if (typeof refreshBestEffortsChartFromUI === 'function') {
          refreshBestEffortsChartFromUI();
        }
        if (typeof refreshRecordsChartFromUI === 'function') {
          refreshRecordsChartFromUI();
        }

      }
    });

    // Find the maximum x value from all datasets
    const maxX = Math.max(...originalDatasets.flatMap(dataset =>
      dataset.data.map(point => point.x)
    ));

    // Configure x-axis based on the provided configuration
    const xAxisOptions = {
      type: 'linear',
      beginAtZero: true,
      max: maxX, // Set max to the highest x value in the data
      title: {
        display: true,
        text: (xAxisConfig && xAxisConfig.label) || 'Distance (km)' // Default to Distance (km)
      }
    };

    // Add time-specific formatting if x-axis is time-based
    if (xAxisConfig && xAxisConfig.type === 'time') {
      xAxisOptions.ticks = {
        maxTicksLimit: 8,
        callback: function(value) {
          return formatTime(value);
        }
      };
    }

    canvas.chart = new Chart(ctx, {
      type: 'line',
      data: {
        datasets: chartDatasets
      },
      options: {
        responsive: true,
        interaction: {
          mode: 'index',
          intersect: false
        },
        scales: {
          x: xAxisOptions,
          y: {
            type: 'linear',
            beginAtZero: true,
            title: {
              display: true,
              text: 'Pace (min/km)'
            },
            grid: {
              drawBorder: true
            },
            ticks: {
              maxTicksLimit: 8,
              callback: function(value) {
                const minutes = Math.floor(value);
                const seconds = Math.floor((value % 1) * 60);
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
              }
            },
            afterFit: function(scale) {
              scale.width = 80;
            }
          }
        },
        plugins: {
          title: {
            display: chartTitle ? true : false,
            text: chartTitle,
            font: {size: 30}
          },
          legend: {
            display: datasets.length > 1,
            position: 'top'
          },
          tooltip: {
            callbacks: {
              title: function(context) {
                const dataIndex = context[0].dataIndex;
                const dataset = originalDatasets[context[0].datasetIndex];
                const point = dataset.data[dataIndex];

                // Use custom label if provided, otherwise format based on x-axis type
                if (point.label) {
                  return point.label;
                } else if (xAxisConfig && xAxisConfig.type === 'time') {
                  return formatTime(context[0].parsed.x);
                } else {
                  return `${context[0].parsed.x} ${(xAxisConfig && xAxisConfig.unit) || 'km'}`;
                }
              },
              label: function(context) {
                const datasetLabel = context.dataset.label || '';
                const minutes = Math.floor(context.parsed.y);
                const seconds = Math.floor((context.parsed.y % 1) * 60);
                return `${datasetLabel}: ${minutes}:${seconds.toString().padStart(2, '0')}`;
              }
            }
          },
          zoom: {
            zoom: {
              wheel: {
                enabled: true,
              },
              pinch: {
                enabled: true
              },
              mode: 'xy',
              onZoomComplete: function({chart}) {
                // Optional: do something after zoom completes
              }
            },
            pan: {
              enabled: true,
              mode: 'xy',
              onPanComplete: function({chart}) {
                // Optional: do something after pan completes
              }
            },
            limits: {
              x: {min: 0, max: maxX},
              y: {min: 0}
            }
          }
        }
      },
      plugins: [toggleButtonPlugin]
    });

    // Add reset zoom button
    const buttonstr = 'button'
    const resetButton = document.createElement(buttonstr);
    resetButton.textContent = 'Reset Zoom';
    resetButton.style.cssText = `
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 8px 12px;
      background-color: #099443;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      z-index: 1000;
    `;

    resetButton.addEventListener('click', function() {
      canvas.chart.resetZoom();
    });

    // Insert reset button relative to canvas
    canvas.parentElement.style.position = 'relative';
    canvas.parentElement.appendChild(resetButton);

    } // End of initializeChart function
  });