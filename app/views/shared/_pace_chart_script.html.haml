:javascript
  document.addEventListener('turbo:load', function() {
    const canvas = document.getElementById('#{chart_id}');
    if (!canvas) return;

    if (canvas.chart) {
      canvas.chart.destroy();
    }

    const canvas_context = '2d';
    const ctx = canvas.getContext(canvas_context);
    const datasets = #{datasets.to_json.html_safe};
    const chartTitle = '#{chart_title}';

    let isPaceMode = true;

    function paceToSpeed(paceInMinutesPerKm) {
      return 60 / paceInMinutesPerKm;
    }

    function speedToPace(speedInKmh) {
      return 60 / speedInKmh;
    }

    function formatPace(value) {
      const minutes = Math.floor(value);
      const seconds = Math.floor((value % 1) * 60);
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function formatSpeed(value) {
      return value.toFixed(1) + ' km/h';
    }

    const toggleButtonPlugin = {
      id: 'toggleButton',
      afterDraw: function(chart) {
        const ctx = chart.ctx;
        const chartArea = chart.chartArea;

        const buttonWidth = 100;
        const buttonHeight = 30;
        const buttonX = chartArea.right - buttonWidth - 10;
        const buttonY = chartArea.bottom - buttonHeight - 10;
        chart.toggleButton = {
          x: buttonX,
          y: buttonY,
          width: buttonWidth,
          height: buttonHeight
        };

        ctx.save();
        ctx.fillStyle = '#28a745';
        ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);

        ctx.fillStyle = '#ffffff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const buttonText = isPaceMode ? 'min/km' : 'km/h';
        ctx.fillText(buttonText, buttonX + buttonWidth/2, buttonY + buttonHeight/2);

        ctx.restore();
      }
    };

    // Store original pace values permanently
    const originalDatasets = datasets.map(dataset => {
      return {
        label: dataset.label,
        data: dataset.data.map(point => ({
          x: point.x,
          y: point.y,
          label: point.label,
          originalPace: point.y
        })),
        backgroundColor: dataset.borderColor || dataset.color, // Use same color as border
        borderColor: dataset.borderColor || dataset.color,
        borderWidth: dataset.borderWidth || 2,
        pointRadius: dataset.pointRadius !== undefined ? dataset.pointRadius : 6,
        pointHoverRadius: dataset.pointHoverRadius !== undefined ? dataset.pointHoverRadius : 8,
        showPoints: dataset.showPoints !== undefined ? dataset.showPoints : true, // New option
        tension: dataset.tension || 0, // Line smoothness
        hidden: dataset.hidden || false,
        fill: false // Disable area fill
      };
    });

    // Create a deep copy for Chart.js to use
    const chartDatasets = originalDatasets.map(dataset => ({
      ...dataset,
      data: dataset.data.map(point => ({...point})),
      // Set point radius based on showPoints option
      pointRadius: dataset.showPoints ? dataset.pointRadius : 0,
      pointHoverRadius: dataset.showPoints ? dataset.pointHoverRadius : 0,
      pointHitRadius: dataset.showPoints ? 10 : 0,
      fill: false // Ensure no area fill
    }));

    function updateChartUnits() {
      const chart = canvas.chart;

      chart.data.datasets.forEach((dataset, index) => {
        const originalDataset = originalDatasets[index];

        if (isPaceMode) {
          dataset.data = originalDataset.data.map(point => ({
            x: point.x,
            y: point.originalPace,
            label: point.label,
            originalPace: point.originalPace
          }));
        } else {
          dataset.data = originalDataset.data.map(point => ({
            x: point.x,
            y: paceToSpeed(point.originalPace),
            label: point.label,
            originalPace: point.originalPace
          }));
        }
      });

      chart.options.scales.y.title.text = isPaceMode ? 'Pace (min/km)' : 'Speed (km/h)';

      chart.options.scales.y.ticks.callback = function(value) {
        return isPaceMode ? formatPace(value) : formatSpeed(value);
      };

      chart.options.plugins.tooltip.callbacks.label = function(context) {
        const datasetLabel = context.dataset.label || '';
        if (isPaceMode) {
          const minutes = Math.floor(context.parsed.y);
          const seconds = Math.floor((context.parsed.y % 1) * 60);
          return `${datasetLabel}: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        } else {
          return `${datasetLabel}: ${context.parsed.y.toFixed(1)} km/h`;
        }
      };

      chart.update();
    }

    canvas.addEventListener('click', function(event) {
      const chart = canvas.chart;
      if (!chart.toggleButton) return;

      const rect = canvas.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;

      if (clickX >= chart.toggleButton.x &&
          clickX <= chart.toggleButton.x + chart.toggleButton.width &&
          clickY >= chart.toggleButton.y &&
          clickY <= chart.toggleButton.y + chart.toggleButton.height) {

        isPaceMode = !isPaceMode;
        updateChartUnits();
      }
    });

    canvas.chart = new Chart(ctx, {
      type: 'line',
      data: {
        datasets: chartDatasets
      },
      options: {
        responsive: true,
        interaction: {
          mode: 'index',
          intersect: false
        },
        scales: {
          x: {
            type: 'linear',
            title: {
              display: true,
              text: 'Distance (km)'
            },
            beginAtZero: true
          },
          y: {
            type: 'linear',
            beginAtZero: true,
            title: {
              display: true,
              text: 'Pace (min/km)'
            },
            grid: {
              drawBorder: true
            },
            ticks: {
              maxTicksLimit: 8,
              callback: function(value) {
                const minutes = Math.floor(value);
                const seconds = Math.floor((value % 1) * 60);
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
              }
            },
            afterFit: function(scale) {
              scale.width = 80;
            }
          }
        },
        plugins: {
          title: {
            display: chartTitle ? true : false,
            text: chartTitle,
            font: {size: 30}
          },
          legend: {
            display: datasets.length > 1, // Only show legend if multiple datasets
            position: 'top'
          },
          tooltip: {
            callbacks: {
              title: function(context) {
                const dataIndex = context[0].dataIndex;
                const dataset = originalDatasets[context[0].datasetIndex];
                return dataset.data[dataIndex].label || `${context[0].parsed.x} km`;
              },
              label: function(context) {
                const datasetLabel = context.dataset.label || '';
                const minutes = Math.floor(context.parsed.y);
                const seconds = Math.floor((context.parsed.y % 1) * 60);
                return `${datasetLabel}: ${minutes}:${seconds.toString().padStart(2, '0')}`;
              }
            }
          }
        }
      },
      plugins: [toggleButtonPlugin]
    });
  });